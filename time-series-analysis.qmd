---
title: "Time Series Analysis of Spotify Data"
author: Frankie, Anna, Piper, Kate, Ayaan
format: 
  html:
    self-contained: true
---

```{r setup, echo=FALSE, message=FALSE}
# load packages
library(tidyverse)
library(knitr)
library(broom)
library(gridExtra)
library(cowplot)
library(xts)
library(forecast)
library(yardstick)
```

```{r load-data, message=FALSE}
# load data
spotify_data = read_csv("data/spotify_data.csv")
spotify_data
```

## Introduction

In this project, we will be analyzing a dataset that contains audio features of more than 160k Spotify songs that were released between 1921 and 2020. The data is collected from Spotify Web API and our group obtained the dataset from Kaggle. The goal of our project is to perform a time-series analysis of Spotify songs using the ARIMA model that was learned in class. We hope to model the average popularity rating of songs within a given year over time. The dataset contains nineteen different features columns, which includes the song name, artist, release date, popularity rating, and some song characteristics, such as acousticness, danceability, loudness, etc. We will begin by dropping some columns from the dataset as they are unnecessary for our analysis. 

## Exploratory data analysis

High-level overview of EDA methods here...

### Data cleaning

```{r}
# data cleaning
cols_to_drop <- c("year", "release_date", "id", "name", "artists")
all_cols <- colnames(spotify_data)
stat_cols<- all_cols[all_cols %in% cols_to_drop == FALSE]

spotify_mean_yearly <- spotify_data %>% 
  group_by(year) %>% 
  summarise_at(stat_cols, list(year_mean = mean))
```

```{r}
colnames(spotify_mean_yearly)
```

### Data visualization

```{r}
# data visualization
pop_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = popularity_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Popularity Mean"
  )

loud_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = loudness_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Loudness Mean"
  )

acoustic_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = acousticness_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Acousticness Mean"
  )

energy_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = energy_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Energy Mean"
  )

danceability_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, danceability_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Danceability Mean"
  )

liveness_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, liveness_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Liveness Mean"
  )

duration_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, duration_ms_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Duration Mean"
  )

instrumentalness_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, instrumentalness_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Instrumentalness Mean"
  )





grid.arrange(pop_line_plot, loud_line_plot, acoustic_line_plot, energy_line_plot, nrow = 2)

grid.arrange(liveness_line_plot, danceability_line_plot, duration_line_plot, instrumentalness_line_plot, nrow = 2)
```

```{r}
plot_for_loop <- function(yearly_data) {
  
  cols_to_plot <- colnames(yearly_data)[colnames(yearly_data) %in% "year" == FALSE]
  
  for (i in 1:length(cols_to_plot)) {
    current_stat <- cols_to_plot[i]
    
    ggplot(data = yearly_data, aes(x = year, y = !! (sym(current_stat)))) +
      geom_line()
  }
  
}

plot_for_loop(spotify_mean_yearly)
```

## Model fitting

```{r step1}
# covert dataframe to time series
spotify_mean_daily <- spotify_data %>% 
  filter(nchar(release_date) > 7) %>% 
  group_by(release_date) %>% 
  summarise_at(stat_cols, list(daily_mean = mean)) %>% 
  arrange(release_date)

spotify_mean_daily$release_date <- as.Date(spotify_mean_daily$release_date, format =  "%Y-%m-%d")
spotify_ts <- xts(spotify_mean_daily$popularity_daily_mean, spotify_mean_daily$release_date)
spotify_ts <- as.ts(spotify_ts)

# forecast ARIMA
step1 <- forecast::ggtsdisplay(spotify_ts, points = FALSE)
```



Based on the time series visualization, we will begin by incorporating
an MA(1) component informed by the PACF echoing pattern. We will also 
store the root mean squared error value to track our progress while 
iterating through ARIMA models.

```{r step2, cache=TRUE}
# MA(1)
step2 <- forecast::Arima(
  spotify_ts, order = c(0, 0, 1)
)
forecast::ggtsdisplay(step2$residuals, points = FALSE, lag.max = 36)

# store rmse value
step2_rmse <- yardstick::rmse_vec(
  spotify_ts %>% unclass(),
  step2$fitted %>% unclass()
)
```

The time series has somewhat improved, but there remains some echoing patterns
that we can alleviate with differencing. We will apply first-order differencing 
on top of the MA(1) process with an $ARIMA(0,1,1)$ model. 

```{r step3, cache=TRUE}
# MA(1)
# first order differencing
step3 <- forecast::Arima(
  spotify_ts, order = c(0, 1, 1)
)
forecast::ggtsdisplay(step3$residuals, points = FALSE, lag.max = 36)

# store rmse value
step3_rmse <- yardstick::rmse_vec(
  spotify_ts %>% unclass(),
  step3$fitted %>% unclass()
 )
```

The differencing definitely improved the model, bringing the root mean squared
error from `r round(step2_rmse, 2)` to `r round(step3_rmse, 2)`. The echoing 
pattern in the PACF has been resolved, but we can move forward by incorporating
an AR component based on the ACF spike. We will add an AR(2) to the existing model, 
resulting in an $ARIMA(2,1,1)$ model.

```{r step4, cache=TRUE}
# MA(1)
# first order differencing
# AR(2)
step4 <- forecast::Arima(
  spotify_ts, order = c(2, 1, 1)
)
forecast::ggtsdisplay(step4$residuals, points = FALSE, lag.max = 36)

# store rmse value
step4_rmse <- yardstick::rmse_vec(
  spotify_ts %>% unclass(),
  step4$fitted %>% unclass()
)
```

```{r auto-model-selection}
forecast::auto.arima(spotify_ts)

```

After utilizing the auto.arima function, we confirm our findings and determine that this is a ARIMA(2,1,1) model. 

```{r model-fit}
# model fit
model = "Final Model - forecast::Arima (2,1,1) "
rmse = (spotify_ts-step4$fitted)^2 %>% mean() %>% sqrt() %>% round(3) %>% paste0("   [RMSE: ", . ,"]")

step4 %>%
  {tibble(
    spotify_ts = spotify_ts %>% unclass(),
    model = .$fitted %>% unclass(),
    time  = time(.$fitted) %>% unclass()
  )} %>% 
  tidyr::gather(var, avg_temp, -time) %>%
  mutate(var = forcats::as_factor(var)) %>%
  ggplot(aes(x=time, y=avg_temp, color=var)) + 
    geom_line(alpha=0.75, size=0.8) +
    labs(title = paste(model, rmse), x = "Time", y = "Average Popularity Score",
         color = "")
```

After applying an MA(1) component, first order differencing, and an AR(2) component,
the model fit appears to be finished! The ACF and PACF do not appear to have a pattern 
after the final step, and the final model against the given data looks sufficient as well. 
The model for this data required the following parameters: $ARIMA(2,1,1)$, and the final 
root mean squared error is `r round(step4_rmse, 2)`.

```{r}


lm1 = lm(popularity~year, data = spotify_data)
glm1 = glm(popularity ~ year, data = spotify_data, family = poisson)
extractAIC(lm1)
lm2 = lm(popularity~year + poly(2, year), data = spotify_data)
extractAIC(lm2)


```

```{r}
lm2 = lm(popularity~year + danceability + loudness + energy + instrumentalness, data = spotify_data)

```

## Discussion

Discussion goes here...