---
title: "Time Series Analysis of Spotify Data"
author: Frankie, Anna, Piper, Kate, Ayaan
format: 
  html:
    self-contained: true
---

```{r setup, echo=FALSE, message=FALSE}
# load packages
library(tidyverse)
library(knitr)
library(broom)
library(gridExtra)
library(cowplot)
library(xts)
library(forecast)
library(yardstick)
library(lubridate)
library(fable)
```

```{r load-data, message=FALSE}
# load data
spotify_data = read_csv("data/spotify_data.csv")
```

## Introduction

In this project, we will be analyzing a dataset that contains information about audio features of more than 160,000 Spotify songs that were released between 1921 and 2020. The data was originally collected from the Spotify Web API and our group obtained the dataset from Kaggle. The goal of our project is to perform a time-series analysis of Spotify songs using the ARIMA model that was learned in class. We hope to model the average popularity rating of songs within a given year over time. The dataset contains nineteen different features columns, which includes the song name, artist, release date, popularity rating, and some song characteristics, such as acousticness, danceability, loudness, etc. 

## Data Preparation and Exploratory data analysis

### Data cleaning

First, we altered the structure of our data, creating a new dataset (`spotify_mean_yearly`) that contains each year from 1921 to 2010 and the mean values of the following feature variables: acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, popularity, speechiness, tempo, and valence. These variables are defined in the codebook in the README file. 

```{r}
# data cleaning
cols_to_drop <- c("year", "release_date", "id", "name", "artists")
all_cols <- colnames(spotify_data)
stat_cols<- all_cols[all_cols %in% cols_to_drop == FALSE]

spotify_mean_yearly <- spotify_data %>% 
  group_by(year) %>% 
  summarise_at(stat_cols, list(year_mean = mean))
```

### EDA: Trends over time

In order to get a general sense of the trends in this data, we have plotted the mean values of each of the song feature variables over time. 

```{r}
# data visualization
pop_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = popularity_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Popularity Mean"
  )

loud_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = loudness_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Loudness Mean"
  )

acoustic_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = acousticness_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Acousticness Mean"
  )

energy_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = energy_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Energy Mean"
  )

danceability_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, danceability_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Danceability Mean"
  )

liveness_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, liveness_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Liveness Mean"
  )

duration_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, duration_ms_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Duration Mean"
  )

instrumentalness_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, instrumentalness_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Instrumentalness Mean"
  )

grid.arrange(pop_line_plot, loud_line_plot, acoustic_line_plot, energy_line_plot, nrow = 2)

grid.arrange(liveness_line_plot, danceability_line_plot, duration_line_plot, instrumentalness_line_plot, nrow = 2)
```

Of note, mean song popularity increased steeply over time. This probably has to do with the rise of the internet and free music streaming, which happened during the last couple of decades. However, mean song popularity decreased sharply in the last couple of years-- perhaps because not as many people have had the chance to listen to certain songs yet. Mean loudness and energy have generally increased over time, while mean song acousticness has dropped. Mean song liveness and instrumetallness had moderate downward trends. Mean song duration rose over time but has dropped again in the last couple of decades. Song danceability fell from the 1920s to the 1950s but has been on an upward trajectory ever since. 

### Bivariate EDA: Relationships between popularity and song features 

### Fitting preliminary ARIMA model to Popularity scores

As part of our EDA, we used a step-by-step process to create an ARIMA model of mean popularity scores over time by year from 1921 to 2020. Ultimately, we will attempt to use an ARIMA component to account for left over temporal autocorrelation of the residuals in our linear model of mean song popularity based on mean song features for a given year; this initial ARIMA model may help us to inform that component by showing us the temporal patterns in song popularity over time. 

```{r step1}
# covert dataframe to time series
spotify_mean_yearly$year <- as.Date(as.character(spotify_mean_yearly$year), format = "%Y")

spotify_ts <- xts(spotify_mean_yearly$popularity_year_mean, spotify_mean_yearly$year)
spotify_ts <- as.ts(spotify_ts)

# forecast ARIMA
step1 <- forecast::ggtsdisplay(spotify_ts, points = FALSE)
```

Based on the time series visualization, we will begin by applying
first-order differencing with an $ARIMA(0,1,0)$ model. We will also 
store the root mean squared error value to track our progress while 
iterating through ARIMA models.

```{r step2, cache=TRUE}
# first-order differencing
step2 <- forecast::Arima(
  spotify_ts, order = c(0, 1, 0)
)
forecast::ggtsdisplay(step2$residuals, points = FALSE, lag.max = 36)

# store rmse value
step2_rmse <- yardstick::rmse_vec(
  spotify_ts %>% unclass(),
  step2$fitted %>% unclass()
)
```

The time series has somewhat improved, but there remains some patterns
that we can alleviate with an AR process. We will apply a AR(1) process
on top of the first-order differencing with an $ARIMA(1,1,0)$ model. 

```{r step3, cache=TRUE}
# first order differencing
# AR(1)
step3 <- forecast::Arima(
  spotify_ts, order = c(1, 1, 0)
)
forecast::ggtsdisplay(step3$residuals, points = FALSE, lag.max = 36)

# store rmse value
step3_rmse <- yardstick::rmse_vec(
  spotify_ts %>% unclass(),
  step3$fitted %>% unclass()
 )
```

The AR component somewhat improved the model, bringing the root mean squared
error from `r round(step2_rmse, 2)` to `r round(step3_rmse, 2)`. We can confirm
our findings using the `auto.arima` function.

```{r auto-model-selection}
# auto arima on time series
forecast::auto.arima(spotify_ts)
```

```{r model-fit}
# model fit
model = "Final Model - forecast::Arima (1,1,0) "
rmse = (spotify_ts-step3$fitted)^2 %>% mean() %>% sqrt() %>% round(3) %>% paste0("   [RMSE: ", . ,"]")

step3 %>%
  {tibble(
    spotify_ts = spotify_ts %>% unclass(),
    model = .$fitted %>% unclass(),
    time  = time(.$fitted) %>% unclass()
  )} %>% 
  tidyr::gather(var, popularity_year_mean, -time) %>%
  mutate(var = forcats::as_factor(var)) %>%
  ggplot(aes(x=time, y=popularity_year_mean, color=var)) + 
    geom_line(alpha=0.75, size=0.8) +
    labs(title = paste(model, rmse), x = "Time", y = "Average Popularity Score",
         color = "")
```

After applying first order differencing and an AR(1) component,
the model fit appears to be finished! The ACF and PACF do not appear to have a pattern 
after the final step, and the final model against the given data looks sufficient as well. 
The model for this data required the following parameters: $ARIMA(1,1,0)$, and the final 
root mean squared error is `r round(step3_rmse, 2)`.

```{r arima-model-output}
# report ARIMA model
as_tsibble(spotify_ts) %>% 
  model(ARIMA(value ~ pdq(1, 1, 0))) %>% 
  report()
```

## Model fitting 

## Discussion

Discussion goes here...


```{r}
plot_for_loop <- function(yearly_data) {
  
  cols_to_plot <- colnames(yearly_data)[colnames(yearly_data) %in% "year" == FALSE]
  
  for (i in 1:length(cols_to_plot)) {
    current_stat <- cols_to_plot[i]
    
    ggplot(data = yearly_data, aes(x = year, y = !! (sym(current_stat)))) +
      geom_line()
  }
  
}

plot_for_loop(spotify_mean_yearly)
```