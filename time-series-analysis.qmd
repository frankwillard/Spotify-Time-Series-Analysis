---
title: "Time Series Analysis of Spotify Data"
author: Frankie, Anna, Piper, Kate, Ayaan
format: 
  html:
    self-contained: true
---

```{r setup, echo=FALSE, message=FALSE}
# load packages
library(tidyverse)
library(knitr)
library(broom)
library(gridExtra)
library(cowplot)
library(xts)
library(forecast)
library(yardstick)
```

```{r load-data, message=FALSE}
# load data
spotify_data = read_csv("data/spotify_data.csv")
```

## Introduction

In this project, we will be analyzing a dataset that contains information about audio features of more than 160,000 Spotify songs that were released between 1921 and 2020. The data was originally collected from the Spotify Web API and our group obtained the dataset from Kaggle. The goal of our project is to perform a time-series analysis of Spotify songs using the ARIMA model that was learned in class. We hope to model the average popularity rating of songs within a given year over time. The dataset contains nineteen different features columns, which includes the song name, artist, release date, popularity rating, and some song characteristics, such as acousticness, danceability, loudness, etc. 

## Data Preparation and Exploratory data analysis

### Data cleaning

First, we altered the structure of our data, creating a new dataset (`spotify_mean_yearly`) that contains each year from 1921 to 2010 and the mean values of the following feature variables: acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, popularity, speechiness, tempo, and valence. These variables are defined in the codebook in the README file. 

```{r}
# data cleaning
cols_to_drop <- c("year", "release_date", "id", "name", "artists")
all_cols <- colnames(spotify_data)
stat_cols<- all_cols[all_cols %in% cols_to_drop == FALSE]

spotify_mean_yearly <- spotify_data %>% 
  group_by(year) %>% 
  summarise_at(stat_cols, list(year_mean = mean))
```

### EDA: Trends over time

In order to get a general sense of the trends in this data, we have plotted the mean values of each of the song feature variables over time. 

```{r}
# data visualization
pop_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = popularity_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Popularity Mean"
  )

loud_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = loudness_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Loudness Mean"
  )

acoustic_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = acousticness_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Acousticness Mean"
  )

energy_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, y = energy_year_mean)) +
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Energy Mean"
  )

danceability_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, danceability_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Danceability Mean"
  )

liveness_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, liveness_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Liveness Mean"
  )

duration_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, duration_ms_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Duration Mean"
  )

instrumentalness_line_plot <- ggplot(data = spotify_mean_yearly, aes(x = year, instrumentalness_year_mean))+
  geom_line() + 
  labs(
    x = "Year",
    y = "Song Instrumentalness Mean"
  )





grid.arrange(pop_line_plot, loud_line_plot, acoustic_line_plot, energy_line_plot, nrow = 2)

grid.arrange(liveness_line_plot, danceability_line_plot, duration_line_plot, instrumentalness_line_plot, nrow = 2)
```
Of note, mean song popularity increased steeply over time. This probably has to do with the rise of the internet and free music streaming, which happened during the last couple of decades. However, mean song popularity decreased sharply in the last couple of years-- perhaps because not as many people have had the chance to listen to certain songs yet. Mean loudness and energy have generally increased over time, while mean song acousticness has dropped. Mean song liveness and instrumetallness had moderate downward trends. Mean song duration rose over time but has dropped again in the last couple of decades. Song danceability fell from the 1920s to the 1950s but has been on an upward trajectory ever since. 

### Bivariate EDA: Relationships between popularity and song features 

## Model fitting

```{r step1}
# covert dataframe to time series
spotify_mean_daily <- spotify_data %>% 
  filter(nchar(release_date) > 7) %>% 
  group_by(release_date) %>% 
  summarise_at(stat_cols, list(daily_mean = mean)) %>% 
  arrange(release_date)

spotify_mean_daily$release_date <- as.Date(spotify_mean_daily$release_date, format =  "%Y-%m-%d")
spotify_ts <- xts(spotify_mean_daily$popularity_daily_mean, spotify_mean_daily$release_date)
spotify_ts <- as.ts(spotify_ts)

# forecast ARIMA
step1 <- forecast::ggtsdisplay(spotify_ts, points = FALSE)
```


Based on the time series visualization, we will begin by incorporating
an MA(1) component informed by the PACF echoing pattern. We will also 
store the root mean squared error value to track our progress while 
iterating through ARIMA models.

```{r step2, cache=TRUE}
# MA(1)
step2 <- forecast::Arima(
  spotify_ts, order = c(0, 0, 1)
)
forecast::ggtsdisplay(step2$residuals, points = FALSE, lag.max = 36)

# store rmse value
step2_rmse <- yardstick::rmse_vec(
  spotify_ts %>% unclass(),
  step2$fitted %>% unclass()
)
```

The time series has somewhat improved, but there remains some echoing patterns
that we can alleviate with differencing. We will apply first-order differencing 
on top of the MA(1) process with an $ARIMA(0,1,1)$ model. 

```{r step3, cache=TRUE}
# MA(1)
# first order differencing
step3 <- forecast::Arima(
  spotify_ts, order = c(0, 1, 1)
)
forecast::ggtsdisplay(step3$residuals, points = FALSE, lag.max = 36)

# store rmse value
step3_rmse <- yardstick::rmse_vec(
  spotify_ts %>% unclass(),
  step3$fitted %>% unclass()
 )
```

The differencing definitely improved the model, bringing the root mean squared
error from `r round(step2_rmse, 2)` to `r round(step3_rmse, 2)`. The echoing 
pattern in the PACF has been resolved, but we can move forward by incorporating
an AR component based on the ACF spike. We will add an AR(2) to the existing model, 
resulting in an $ARIMA(2,1,1)$ model.

```{r step4, cache=TRUE}
# MA(1)
# first order differencing
# AR(2)
step4 <- forecast::Arima(
  spotify_ts, order = c(2, 1, 1)
)
forecast::ggtsdisplay(step4$residuals, points = FALSE, lag.max = 36)

# store rmse value
step4_rmse <- yardstick::rmse_vec(
  spotify_ts %>% unclass(),
  step4$fitted %>% unclass()
)
```

```{r auto-model-selection}
forecast::auto.arima(spotify_ts)

```

After utilizing the auto.arima function, we confirm our findings and determine that this is a ARIMA(2,1,1) model. 

```{r model-fit}
# model fit
model = "Final Model - forecast::Arima (2,1,1) "
rmse = (spotify_ts-step4$fitted)^2 %>% mean() %>% sqrt() %>% round(3) %>% paste0("   [RMSE: ", . ,"]")

step4 %>%
  {tibble(
    spotify_ts = spotify_ts %>% unclass(),
    model = .$fitted %>% unclass(),
    time  = time(.$fitted) %>% unclass()
  )} %>% 
  tidyr::gather(var, avg_temp, -time) %>%
  mutate(var = forcats::as_factor(var)) %>%
  ggplot(aes(x=time, y=avg_temp, color=var)) + 
    geom_line(alpha=0.75, size=0.8) +
    labs(title = paste(model, rmse), x = "Time", y = "Average Popularity Score",
         color = "")
```

After applying an MA(1) component, first order differencing, and an AR(2) component,
the model fit appears to be finished! The ACF and PACF do not appear to have a pattern 
after the final step, and the final model against the given data looks sufficient as well. 
The model for this data required the following parameters: $ARIMA(2,1,1)$, and the final 
root mean squared error is `r round(step4_rmse, 2)`.

```{r}
lm1 = lm(popularity~year, data = spotify_data)
glm1 = glm(popularity ~ year, data = spotify_data, family = poisson)
extractAIC(lm1)
lm2 = lm(popularity~year + poly(2, year), data = spotify_data)
extractAIC(lm2)


```

```{r}
lm2 = lm(popularity~year + danceability + loudness + energy + instrumentalness, data = spotify_data)

```

## Discussion

Discussion goes here...





```{r}
plot_for_loop <- function(yearly_data) {
  
  cols_to_plot <- colnames(yearly_data)[colnames(yearly_data) %in% "year" == FALSE]
  
  for (i in 1:length(cols_to_plot)) {
    current_stat <- cols_to_plot[i]
    
    ggplot(data = yearly_data, aes(x = year, y = !! (sym(current_stat)))) +
      geom_line()
  }
  
}

plot_for_loop(spotify_mean_yearly)
```